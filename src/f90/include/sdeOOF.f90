module sdeOOF
  ! by Benjamin D. Wandelt and Krzysztof M. Gorski, 1998
  ! Modified by E. Keihanen, 2002: Normalization according to the knee
  !                                frequency power.
  ! Modified by H. K. Eriksen, 2010: Leaner code, and introduced physical 
  !                                units in the interface. Switched to 
  !                                ziggurat and double precision
  !--------------------------------------------------------------------
  ! CONTENTS:
  ! subroutine initialize_SDE
  ! subroutine reset_SDE
  ! function predicted_spectrum
  ! subroutine cleanup_SDE_oof
  ! function SDE_oof
  
  !--------------------------------------------------------------------
  ! WHAT THIS MODULE DOES:
  ! This module allows the generation of a 1-D Gaussian processes
  ! whose power spectrum approximates the form P(f)~ f**slope
  ! where  -2 < slope < 0, with possible low/high frequency cutoffs.
  ! It further supports easy generation of processes with power
  ! spectrum P(f)=sigma^2(1+(f/fknee)**slope).
  
  ! The routine models the process as a superposition of a number of
  ! component processes each of which has a power spectrum of the
  ! form P(f) = a^2/(1+ (a f)**2). These component processes are
  ! generated by evolving a set of simple stochastic differential
  ! equations (see Wandelt and Gorski 1998 for a more detailed
  ! explanation).
  
  !--------------------------------------------------------------------
  ! SPEED AND MEMORY:
  ! The computational complexity is O( N n ), where 'N' is the total
  ! length of the generated process  and 'n' the number of component
  ! processes (which scales as the number of decades in frequency
  ! where the power spectrum has a 1 /f behaviour, hence overall
  ! scaling is O( N Log(N) ). Memory requirements are minimal
  ! because FFTs are avoided.
  
  !--------------------------------------------------------------------
  ! HOW TO USE THE ROUTINES IN THIS MODULE:
  ! To use, first call the subroutine 'initialize_SDE', which will
  ! allocate and initialise the necessary workspace. Then calling the
  ! function 'SDE_oof' repeatedly will deliver the 1/f
  ! process. When you have generated your 1/f process, call
  ! the subroutine 'cleanup_SDE_oof' to free the workspace. The
  ! function 'predicted_spectrum' computes the expected spectrum
  ! of the resulting process.
  
  !--------------------------------------------------------------------
  use healpix_types ! HKE
  use ziggurat
  implicit none
  
  integer(i4b),              private :: nprocesses
  real(dp),     allocatable, private :: h(:), y0(:)
  real(dp),     allocatable, private :: tau(:), ttau(:), weight(:)
  real(dp),                  private :: sigma, fknee, slope, f0
  logical(lgt),              private :: whiteQ
  type(zig_rng),             private :: rng
  
contains
  
  subroutine initialize_SDE(seed, sigma_in, fknee_in, slope_in, samprate_in, f0_in, whiteQ_in)
    !
    ! DESCRIPTION: This subroutine is meant as an easy-to-use
    ! interface to the subroutine initialise_SDE_oof for usage with
    ! power-spectra of the type P(f)=sigma^2(1+(f/fknee)^slope).
    
    ! INPUTS:
    ! The subroutine initialize_SDE requires the following input
    ! parameters:
    
    ! seedh: integer which initialises the random number
    ! generator.
    
    ! sigma: (real) white noise level, used for normalization.

    ! fknee: (real) The frequency where the power spectrum turns over
    ! from low frequency 1/f^alpha to white noise. This is specified
    ! in Hz.
    
    ! slope: (real) power law slope of the low-frequency power
    ! spectrum. Should be between 0 and -2.
    
    ! samprate: Sampling rate of experiment in Hz

    ! f0: (real) minimum frequency below which the power spectrum
    ! levels out, given in Hz.
    
    ! whiteQ: (logical) add white noise?
    
    ! OUTPUTS: None
    
    ! COMMENTS: You can call this subroutine repeatedly to start
    ! generating processes with different parameters, without having to
    ! call 'cleanup_SDE_oof' every time.
    
    ! tau1, tau2: Short time (tau1) and long time (tau2) cutoffs. Above
    ! the frequency corresponding to tau1 time steps, the process will
    ! turn over to a f^(-2) power spectrum. Below the frequency
    ! corresponding to tau2 time steps, the process will turn over to a
    ! white noise power spectrum. If you want 1/f power through the
    ! full range of frequencies set tau1=1 and tau2=N.
    
    !--------------------------------------------------------------------
    
    real(dp),     intent(in) :: sigma_in, fknee_in, slope_in, f0_in, samprate_in
    integer(i4b), intent(in) :: seed
    logical(lgt), intent(in) :: whiteQ_in

    real(dp)     :: tau1, tau2
    integer(i4b) :: i
    
    sigma  = sigma_in
    fknee  = fknee_in * pi / (0.5d0*samprate_in) ! Highest frequency = samprate/2 = 0.5 * (2*pi)
    slope  = slope_in
    f0     = f0_in    * pi / (0.5d0*samprate_in) ! Highest frequency = samprate/2 = 0.5 * (2*pi)
    whiteQ = whiteQ_in
    
    ! Initialize random number generator
    call zig_init(rng, seed)
    
    tau1 = 1.7d0      ! works well empirically
    tau2 = 1.d0/f0
    
    nprocesses = floor(2*log10(tau2/tau1))
    write(*,*) "nprocesses =", nprocesses
    
    ! Attempt to allocate memory and initialise vectors
    if(allocated(h)) deallocate(h)
    allocate(h(1:nprocesses))
    h=0.d0
    
    if(allocated(tau)) deallocate(tau)
    allocate(tau(1:nprocesses))
    tau=(/(real(i,dp)/real(nprocesses-1,dp),i=0,nprocesses-1)/)
    tau = tau1 * (tau2/tau1)**tau
    
    if(allocated(ttau)) deallocate(ttau)
    allocate(ttau(1:nprocesses))
    ttau=1.d0-1.d0/tau

    if(allocated(y0)) deallocate(y0)
    allocate(y0(1:nprocesses))
    
    call reset_SDE(1) ! EK
    
    if(allocated(weight)) deallocate(weight)
    allocate(weight(1:nprocesses))
    weight = tau**(-0.5d0*slope-1.d0)  ! E.K.
    weight = weight*sigma/sqrt(predicted_spectrum(fknee))  ! E.K.
    
  end subroutine initialize_SDE

  
  ! This routine initializes the noise stream.
  ! mode: (integer) Set mode=1 to get stationary noise.
  !                 Set mode=0 to start the noise stream from zero.
  subroutine reset_SDE(mode)
    implicit none
    
    integer(i4b),intent(in) :: mode
    integer(i4b)  :: i
    if (mode==0) then
       y0 = 0.d0
    else
       do i = 1, nprocesses
          y0(i) = zig_gauss(rng)
       end do
       y0 = y0*sqrt(tau/(2.d0-1.d0/tau))
    endif
  end subroutine reset_SDE
  
  
  ! This function computes the expected power of the 1/f part of the noise at the input frequency.
  function predicted_spectrum(x)
    implicit none
    real(dp),  intent(in) :: x
    real(dp)     :: predicted_spectrum
    integer(i4b) :: i
    predicted_spectrum = 0.d0
    do i = 1, nprocesses
       predicted_spectrum = predicted_spectrum + weight(i)**2*tau(i)**2/(1.d0+(x*tau(i))**2)
    enddo
  end function predicted_spectrum
  
  
  ! This subroutine frees the workspace of this
  subroutine cleanup_SDE_oof()
    deallocate(h,y0,tau,ttau,weight)
  end subroutine cleanup_SDE_oof
  
  
  ! This function evolves and outputs the process step for step.
  function SDE_oof()
    implicit none
    
    real(dp)     :: SDE_oof
    integer(i4b) :: i
    
    ! Draw N Gaussian numbers
    do i = 1, nprocesses
       h(i) = zig_gauss(rng)
    end do
    
    ! evolve system of SDE's one step further
    y0 = y0*ttau + h
    
    SDE_oof = sum(y0*weight) ! weighted sum is the desired output
    
    if(whiteQ) SDE_oof = SDE_oof +sigma*zig_gauss(rng)
    
  end function SDE_oof
  
end module sdeOOF
